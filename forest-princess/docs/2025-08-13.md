## forest-princess: Vue + Canvas로 2D 게임을 모노레포에서 빌드하기(1편: 2025-08-13)

Nuxt 모노레포 안에서 2D 게임을 "바닥부터" 구현하는 프로젝트를 진행 중이다. 최종 목표는 누구나 쉽게 쓸 수 있는 웹 기반 게임 도구를 만드는 것이고, 이 글에서는 현재까지의 여정과 아키텍처를 공유한다. 개발이 진행되면서 새로운 기능 구현 과정을 계속 포스팅할 예정이다. 현재 구현의 핵심은 다음 두 가지다.

- 웹의 빠른 GUI 생산성은 그대로 활용한다(메뉴, 인벤토리 등은 DOM).
- 게임 화면만 Canvas 2D로 그린다(렌더 루프, 카메라, 스프라이트, 충돌/획득 등).

### 왜 모노레포인가: nuxt-core의 공유와 재사용

모노레포를 선택한 가장 큰 이유는 이미 구축해둔 `nuxt-core`를 활용하기 위해서다. `nuxt-core`에는 기존 `svg-mapper` 등의 프로젝트를 진행하면서 축적한 SVG/Canvas 수식, 프레임 루프(`animatedFrame`), 리사이즈 옵저버, 명령 입력 맵핑 등이 들어있다. 이런 검증된 유틸들을 새로운 게임 프로젝트(`forest-princess`)에서도 그대로 활용할 수 있어 개발 속도를 크게 높일 수 있었다.

### 왜 Nuxt + Vue인가: SEO와 Pinia

- SEO: 나중에 업적 시스템/유저 활동을 검색 가능하게 만들 때 Nuxt가 유리하다.
- **Pinia를 시스템처럼 운용**: `useCanvas`, `useLoots`, `useInventory` 등 각 기능을 싱글톤 스토어로 두고 상호작용(예: 플레이어-루팅-인벤토리)을 느슨하게 결합한다. Vue의 컴포저블 경험을 유지하면서도 복잡한 게임 로직을 간단히 엮을 수 있었다.

## 아키텍처 개요: DOM + Canvas 하이브리드

**핵심 아이디어는 UI와 게임 렌더링을 분리**하는 것이다. 일반 UI(메뉴, 인벤토리)는 DOM으로 즉시성 있게 만들어 프레임마다 다시 그릴 필요가 없게 하고, 게임 월드와 오브젝트만 Canvas 2D로 렌더한다. 이렇게 하면 **리렌더 비용과 반응형 문제를 분리**할 수 있다.

인벤토리 UI는 실제로 DOM에 얹힌다. Canvas 위에 절대 배치된 단순한 카드 슬롯들로, 반응형도 수월하다. **입력 맵핑도 분리**해서 `useCommand({ map: commandMap })`로 키 바인딩 변경이나 패드 지원 확장이 쉽다.

```html
<!-- 인벤토리 UI (DOM) -->
<div class="absolute bottom-20 left-1/2 flex -translate-x-1/2 gap-2 rounded-md bg-white/70 p-2 shadow">
  <template v-for="slotNum in inventory.state.slots" :key="slotNum">
    <div class="relative h-10 w-10 rounded border border-slate-300 bg-white">
      <div v-if="inventory.state.items[slotNum - 1]" class="absolute inset-1 rounded bg-slate-400/80">
        <img :src="inventory.state.items[slotNum - 1]!.srcUrl" class="h-full w-full object-contain" />
      </div>
    </div>
  </template>
</div>
```

### 인벤토리 렌더링: img → canvasImg 전환 중(WIP)

현재는 `<img>`로 아이콘을 그리지만, 슬롯마다 캔버스를 두는 `canvasImg` 컴포넌트로 전환 중이다. 이렇게 하면 이후 애니메이션(프레임 드로잉), 색상 변조, 글로우/섀도우 같은 특수효과를 동일한 2D 컨텍스트에서 손쉽게 적용할 수 있다.

```html
<script setup lang="ts">
  const props = defineProps<{
    src: CanvasImageSource | null;
    width: number;
    height: number;
  }>();

  const canvasRef = ref<HTMLCanvasElement | null>(null);

  onMounted(() => {
    if (canvasRef.value && props.src) {
      const ctx = canvasRef.value.getContext("2d");
      if (ctx) {
        ctx.drawImage(props.src, 0, 0, props.width, props.height);
      }
    }
  });
</script>

<template>
  <canvas ref="canvasRef" :width="width" :height="height" />
</template>
```

전환 계획은 다음과 같다.

- 슬롯마다 `canvasImg`를 마운트하고, 인자로 아이템 스프라이트와 타임라인(또는 프레임 인덱스)을 전달
- 공용 스프라이트 로더/리사이저(`resizeImage`) 재사용, 필요 시 오프스크린 캔버스로 사전 변환
- 효과 파이프라인(색 보정, 테두리, 하이라이트)을 캔버스 드로잉에 체인 형태로 적용

반면, 캔버스는 전용 스토어로 관리한다. 컨텍스트 생성, 리사이즈, 프레임 루프를 한 곳에서 캡슐화했다.

```ts
const draw = ({ totalTime, deltaTime }: AnimatedFrameCallbackProps) => {
  if (!ctx.value) return;
  ctx.value.clearRect(0, 0, canvasRef.value!.width, canvasRef.value!.height);
  watchUpdateCallback?.({ ctx: ctx.value, totalTime, deltaTime });
};
```

```ts
watch(canvasRef, (newCanvas, _, onCleanup) => {
  if (newCanvas) {
    newCanvas.width = newCanvas.clientWidth;
    newCanvas.height = newCanvas.clientHeight;
    ctx.value = newCanvas.getContext("2d");
    ctx.value!.imageSmoothingEnabled = true;
    ctx.value!.imageSmoothingQuality = "high";
    $animatedFrame = animatedFrame(draw);
    onCleanup(() => {
      $animatedFrame?.destroy();
    });
  }
});
```

## 카메라: 추적과 경계 클램프, 줌

2D 카메라는 월드 좌상단 좌표와 줌을 상태로 들고, 타깃(플레이어)을 부드럽게 추적한다. **지수 보간**(`alpha = 1 - exp(-k * deltaTime)`)으로 자연스러운 추적을 구현했고, `k` 값 하나로 반응성을 직관적으로 조절할 수 있다. 또한 `setBounds`로 맵 경계를 설정하면 카메라가 월드 밖으로 나가지 않도록 클램프된다.

```ts
const update = ({ deltaTime }: { deltaTime: number }) => {
  if (isFollowEnabled.value && followTarget.value) {
    const t = toFollowTarget(followTarget.value)!;
    const targetCenterX = t.x + t.width / 2;
    const targetCenterY = t.y + t.height / 2;
    const desiredX = targetCenterX - state.value.width / (2 * state.value.zoom);
    const desiredY = targetCenterY - state.value.height / (2 * state.value.zoom);

    // 지수 보간으로 부드럽게 추적
    const k = 0.008; // 추적 강도
    const alpha = 1 - Math.exp(-k * deltaTime);
    state.value.x += (desiredX - state.value.x) * alpha;
    state.value.y += (desiredY - state.value.y) * alpha;

    clampToBounds();
  }
};
```

렌더 시 `begin/end`로 월드 공간을 캔버스에 투영한다.

```ts
const begin = (ctx: CanvasRenderingContext2D) => {
  ctx.save();
  ctx.scale(state.value.zoom, state.value.zoom);
  ctx.translate(-Math.floor(state.value.x), -Math.floor(state.value.y));
};

const end = (ctx: CanvasRenderingContext2D) => {
  ctx.restore();
};
```

## 오브젝트: 플레이어, 나무, 루팅 아이템

게임 오브젝트들은 **ECS 스타일의 렌더 계약**을 따른다. `drawObjects(ctx, [{ state, render }, ...])`로 각 오브젝트는 자신의 `render` 함수만 구현하면 되어 교체나 테스트가 쉽다.

**루팅 시스템**은 AABB 기반으로, 겹치는 영역이 루트 영역의 절반을 넘으면 획득한다. 이 임계값 하나로 체감 난이도를 간단히 조정할 수 있어 프로토타이핑에 유리하다.

```ts
// 겹치는 영역이 전체 루트 영역의 절반을 넘으면 루팅되게 변경
const checkLootOverlap = (loots: LootInstance): Loot[] => {
  const pickupLoots: Loot[] = [];
  loots.state.forEach((loot) => {
    // 교집합 영역 계산
    const overlapX = Math.max(0, Math.min(state.x + state.width, loot.x + loot.width) - Math.max(state.x, loot.x));
    const overlapY = Math.max(0, Math.min(state.y + state.height, loot.y + loot.height) - Math.max(state.y, loot.y));
    const overlapArea = overlapX * overlapY;
    const lootArea = loot.width * loot.height;

    // 겹치는 영역이 루트 전체의 절반을 넘으면 루팅
    if (overlapArea > lootArea / 2) {
      pickupLoots.push(loot);
    }
  });
  return pickupLoots;
};
```

```ts
const loadSprite = () => {
  const lootImage = new Image();
  lootImage.src = logIdle;
  lootImage.onload = () => {
    sprite.value = resizeImage(lootImage, baseWidth, baseHeight);
    console.log(state.size);
    state.forEach((l, key) => {
      state.set(key, { ...l, src: sprite.value });
    });
  };
};
```

```ts
const render = ({ ctx, state }: RenderLootProps) => {
  ctx.save();
  if (state.src) {
    ctx.drawImage(state.src, state.x, state.y, state.width, state.height);
  }
  ctx.restore();
};
```

렌더 단계는 카메라 변환을 적용한 뒤, 단일 헬퍼로 순서대로 그린다.

```ts
camera.begin(ctx);
drawObjects(ctx, [
  ...trees.state.map((tree) => ({ state: tree, render: trees.render })),
  ...Array.from(loots.state.values()).map((loot) => ({ state: loot, render: loots.render })),
  player,
]);
camera.end(ctx);
```

## 최적화 관점: 지금과 다음

현재는 기본적인 품질 설정과 구조적 분리에 집중했다.

- 캔버스 리사이즈/스케일 품질 제어: `imageSmoothingEnabled`, `imageSmoothingQuality`.
- 프레임 루프 캡슐화: `animatedFrame(draw)`로 구독 기반 업데이트.
- UI/인게임 렌더 분리: DOM 인벤토리는 매 프레임 리렌더가 필요 없다.

추가로, **AI/NPC 대사를 위한 Web Worker 파이프라인**을 별도 프로젝트에서 실험 중이다. 브라우저에서 직접 Transformers.js 모델을 로딩해 생동감 있는 NPC 대화를 만들려는 시도다.

```ts
const pl = await pipeline(task as PipelineType, model, {
  progress_callback: (e: any) => {
    const event: ProgressEvent = {
      status: e.status ?? "progress",
      file: e.file,
      loaded: e.loaded,
      total: e.total,
    };
    logs.push(event);
    // 진행률 계산 및 보관 (메인 스레드에서 폴링)
    if (typeof e?.loaded === "number" && typeof e?.total === "number" && e.total > 0) {
      const pct = Math.max(0, Math.min(99, Math.round((e.loaded / e.total) * 100)));
      progressByKey.set(cacheKey, pct);
    }
  },
});
```

```ts
export async function runPipeline(
  task: SupportedTask,
  model: string,
  input: TextInput | QaInput,
  options?: RunOptions,
) {
  const logs: ProgressEvent[] = [];
  try {
    const pl = await getPipeline(task, model, logs);

    console.log("input: ", input);
    if (task === "question-answering") {
      const { question, context } = input as QaInput;
      const result = await pl({ question, context }, options ?? {});
      return { ok: true, result, logs } as const;
    }

    const result = await pl(input as TextInput, options ?? {});
    console.log("result: ", result);
    return { ok: true, result, logs } as const;
  } catch (err: any) {
    logs.push({ status: "error", file: undefined });
    return { ok: false, error: err?.message ?? String(err), logs } as const;
  }
}
```

향후에는 이런 무거운 작업들을 워커/오프스크린 캔버스로 분리해 메인 스레드 프레임 안정성을 확보할 계획이다.

## Unity와의 비교: 내가 원하는 트레이드오프

- 물리/3D/툴링은 Unity가 훨씬 강력하다. 반면 2D 위주의 내 요구엔 과하다.
- 웹의 장점: 즉시 배포, 가벼운 로딩, SEO, 표준 GUI 가속, 쉬운 반응형.
- Vue+Pinia 조합은 상태를 모듈별 싱글톤처럼 다루기 쉬워 게임 시스템을 얽기 편했다.

## 앞으로의 계획

- 충돌 최적화: 간단한 쿼드트리/타일 파티셔닝으로 충돌/획득 후보 줄이기.
- 애니메이션: 스프라이트 아틀라스와 타임라인 기반 워킹/아이들 스테이트.
- 카메라: 맵 바운드 동적 추출, 스크린 셰이크, 줌 인/아웃 연출.
- 렌더링: 오프스크린 캔버스 + 워커 조합 시험, 대규모 오브젝트 리스트 스트리밍.
- 저장/공유: 세이브 슬롯과 공유용 스냅샷(SEO 친화 링크) 설계.

## 현재 상황과 다음 계획

웹의 GUI 구현 속도와 배포/검색 친화성을 활용한 DOM + Canvas 하이브리드 접근법이 잘 맞는다는 걸 확인했다. 모노레포의 `nuxt-core`로 수학/프레임 루프/유틸을 공유하고, Nuxt + Pinia로 상태와 라우팅/SEO를 정돈하는 구조도 게임 개발에 적합하다.

현재는 최소한의 시스템(카메라, 이동, 루팅, 렌더 루프)을 구현한 상태다. 다음 단계는 워커/오프스크린을 통한 부하 분리와 콘텐츠 도구화를 진행할 예정이다.

**앞으로 새로운 기능을 구현할 때마다 별도의 포스트로 개발 과정을 공유할 예정이다.** 애니메이션 시스템, AI NPC 대화, 맵 에디터 등 각 기능의 구현 과정과 고민들을 연재 형태로 작성할 계획이다.

---

**Tags:** `#canvas` `#vue` `#nuxt` `#animation` `#pinia` `#모노레포` `#게임개발` `#웹게임` `#개발일지` `#태그`
